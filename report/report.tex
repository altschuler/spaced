\documentclass[danish]{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{color}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}

\pagestyle{fancy}
\fancyhf{}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{\thepage{} af \pageref{LastPage}}
\rfoot{DATO}
\rhead{MEMBERS}
\chead{Space Invaders}
\lhead{}

% use when representing code and file names
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\section*{Opbygning}
\subsection{Overordnet struktur}
Vi vil her beskrive programmets overordnede opbygnings filosofi/struktur. Programmet er opbygget med
den klassiske MVC arkitektur. MVC er blevet brugt og beskrevet s� meget at det n�sten kan siges at
v�re blevet en klich�. Det er umuligt at definere helt pr�cist hvordan en egentlig korrekt
implementering ser ud, men de overordnede princippet g�lder mere eller mindre for alle varianter.

I vores tilf�lde har vi en \code{MainController}, \code{MainView} og \code{MainModel}. Udover det
bruger vi Command pattern til at facilitere eksekvering af ``cachet'' logik, og Observer pattern til
at opdatere views n�r modellen �ndres. Vi gennemg�r kort nogle vigtige klasser og principper:

\begin{description}
\item[\code{MainController}] \hfill \\
  Den overordnede controller, som holder instanser af sub-controllers og ikke laver noget egentligt
  arbejde selv. Pointen er, at har man en reference til \code{MainController}, kan man tilg� alle
  andre controllers som getters p� denne. Dette g�r det nemt og bekvemt at kalde forskellige sub
  controller metoder fra forskellige steder uden at skulle sende hver enkel controller rundt for
  sig.

\item[\code{MainView}]  \hfill \\
  Det �verste view, hvori alle andre views bliver renderet. \code{MainView} indeholder p� ethvert
  givent tidspunkt �n instans af \code{AbstractViewState}, som bliver renderet i vinduet. Denne
  s�ttes gennem en Command som kalder en metode p� \code{StateController}.

\item[\code{MainModel}]  \hfill \\
  Den overordnede model. Heri ligger al data som beskriver programmets nuv�rende tilstand. Dette
  inkluderer alt fra hvor stort hovedvinduet er, til hvorn�r man sidst har affyret et skud. Al data
  som er en del af en specifik spille-session (dvs, hvor mange invaders er der, hvor er de, hvorn�r
  blev spillet sidst opdateret og renderet), bliver gemt i et \code{GameState} object. Dette gemmes
  i \code{MainModel} som det aktive spille-sessions state. Dette object er d�t som bliver givet til
  en \code{GameController}, der s� opdaterer det og sender det til rendering.

\item[Commands] \hfill \\
  \code{Command}s bliver brugt til at enkapsulere logik der \emph{kan v�re} afh�ngig af state. Denne
  logik kan s� efterf�lgende eksekveres af hvem som helst, n�r som helst, uden at denne har nogen
  viden om hvad en given \code{Command} \emph{egentlig} g�r. F�lles for dem alle er at implementerer
  \code{ICommand} interfacet, hvilket best�r af en enkelt metode: \code{execute}.  Det er specielt
  bekvemt til f.eks. at eksekvere logik ved tryk p� knapper (hvor knappen ikke skal vide hvad den
  laver), men ogs� til generelt at lagre og udf�re logik fra andre steder.  Vi har det klassiske
  command pattern en smule ved at implementere en \code{chain} metode, som effektivt s�tter
  \code{Command}s sammen i r�kkef�lge og returnerer en ny command.

\item[Observers] \hfill \\
  \code{MainModel} implementerer Java's \code{Observable}. Det er en m�de for et object at eksponere
  et interface som g�r et andet object, en \code{Observer}, opm�rksom p� hvorn�r den er
  opdateret. Vha. observer pattern g�res dette fuldst�ndig decoupled, og \code{MainModel} har alts�
  ingen ide om hvem der lytter efter dens �ndringer. �ndringerne annonceres gennem
  \code{Oberservable}s \code{notifyObservers} metode.
\end{description}

\section{GameController}
Står primært for at opdatere \code{GameState} samt at få GameStateRenderer (kaldet renderer under GameController) til at rendere GameState.
\\Derudover anvender den javax.swing.Timer, som med faste intervaller kalder en metode... SIMON - hilfe mich!
\\Metoden updateGameState gør følgende (i kronologisk rækkefølge):
\begin{enumerate}
\item currentTime og timeDelta... (vend tilbage til dette) timeDelta bruges til at bevæge samtlige GameElement’er afhængigt af den tid der er gået, sådan at de for spilleren bevæger sig med konstant hastighed uafhængigt af om tiden mellem updates varierer (probs til Simon).
\item Kontrollerer om GameStateState er Running/Waiting/Paused. Hvis denne enum er waiting/paused returnerer metoden og kører dermed ikke videre. Hvis den er running fortsætter den og tjekker om spilleren eventuelt trykker ESC for at pause (og returnere).
\item Herefter bliver alle GameElement’erne opdateret og eventuelt fjernet hvis de er “døde” (metoderne for dette er uddybet nedenfor).
\item Tjekker om man har vundet/tabt og returnerer hvis dette er tilfældet.Kalder GameStateRenderer og får denne til at rendere det aktuelle GameState.
\item Kalder GameStateRenderer og får denne til at rendere det aktuelle GameState.
\item Slutteligt opdateres tiden gemt i GameState.
\end{enumerate}

\end{document}